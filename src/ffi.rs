/* automatically generated by rust-bindgen 0.70.1 */

pub const WEBP_ENCODER_ABI_VERSION: u32 = 527;
pub const WEBP_MAX_DIMENSION: u32 = 16383;
pub const WEBP_DECODER_ABI_VERSION: u32 = 521;
pub const WEBP_MUX_ABI_VERSION: u32 = 265;
pub const WEBP_DEMUX_ABI_VERSION: u32 = 263;
extern "C" {
    pub fn WebPMalloc(size: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn WebPFree(ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn WebPGetEncoderVersion() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPEncodeRGB(
        rgb: *const u8,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        stride: ::core::ffi::c_int,
        quality_factor: f32,
        output: *mut *mut u8,
    ) -> usize;
}
extern "C" {
    pub fn WebPEncodeBGR(
        bgr: *const u8,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        stride: ::core::ffi::c_int,
        quality_factor: f32,
        output: *mut *mut u8,
    ) -> usize;
}
extern "C" {
    pub fn WebPEncodeRGBA(
        rgba: *const u8,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        stride: ::core::ffi::c_int,
        quality_factor: f32,
        output: *mut *mut u8,
    ) -> usize;
}
extern "C" {
    pub fn WebPEncodeBGRA(
        bgra: *const u8,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        stride: ::core::ffi::c_int,
        quality_factor: f32,
        output: *mut *mut u8,
    ) -> usize;
}
extern "C" {
    pub fn WebPEncodeLosslessRGB(
        rgb: *const u8,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        stride: ::core::ffi::c_int,
        output: *mut *mut u8,
    ) -> usize;
}
extern "C" {
    pub fn WebPEncodeLosslessBGR(
        bgr: *const u8,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        stride: ::core::ffi::c_int,
        output: *mut *mut u8,
    ) -> usize;
}
extern "C" {
    pub fn WebPEncodeLosslessRGBA(
        rgba: *const u8,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        stride: ::core::ffi::c_int,
        output: *mut *mut u8,
    ) -> usize;
}
extern "C" {
    pub fn WebPEncodeLosslessBGRA(
        bgra: *const u8,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        stride: ::core::ffi::c_int,
        output: *mut *mut u8,
    ) -> usize;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WebPImageHint {
    WEBP_HINT_DEFAULT = 0,
    WEBP_HINT_PICTURE = 1,
    WEBP_HINT_PHOTO = 2,
    WEBP_HINT_GRAPH = 3,
    WEBP_HINT_LAST = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPConfig {
    pub lossless: ::core::ffi::c_int,
    pub quality: f32,
    pub method: ::core::ffi::c_int,
    pub image_hint: WebPImageHint,
    pub target_size: ::core::ffi::c_int,
    pub target_PSNR: f32,
    pub segments: ::core::ffi::c_int,
    pub sns_strength: ::core::ffi::c_int,
    pub filter_strength: ::core::ffi::c_int,
    pub filter_sharpness: ::core::ffi::c_int,
    pub filter_type: ::core::ffi::c_int,
    pub autofilter: ::core::ffi::c_int,
    pub alpha_compression: ::core::ffi::c_int,
    pub alpha_filtering: ::core::ffi::c_int,
    pub alpha_quality: ::core::ffi::c_int,
    pub pass: ::core::ffi::c_int,
    pub show_compressed: ::core::ffi::c_int,
    pub preprocessing: ::core::ffi::c_int,
    pub partitions: ::core::ffi::c_int,
    pub partition_limit: ::core::ffi::c_int,
    pub emulate_jpeg_size: ::core::ffi::c_int,
    pub thread_level: ::core::ffi::c_int,
    pub low_memory: ::core::ffi::c_int,
    pub near_lossless: ::core::ffi::c_int,
    pub exact: ::core::ffi::c_int,
    pub use_delta_palette: ::core::ffi::c_int,
    pub use_sharp_yuv: ::core::ffi::c_int,
    pub qmin: ::core::ffi::c_int,
    pub qmax: ::core::ffi::c_int,
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPConfig() {
    const UNINIT: ::core::mem::MaybeUninit<WebPConfig> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPConfig>(),
        116usize,
        "Size of WebPConfig"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPConfig>(),
        4usize,
        "Alignment of WebPConfig"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lossless) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPConfig::lossless"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quality) as usize - ptr as usize },
        4usize,
        "Offset of field: WebPConfig::quality"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        8usize,
        "Offset of field: WebPConfig::method"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).image_hint) as usize - ptr as usize },
        12usize,
        "Offset of field: WebPConfig::image_hint"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target_size) as usize - ptr as usize },
        16usize,
        "Offset of field: WebPConfig::target_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target_PSNR) as usize - ptr as usize },
        20usize,
        "Offset of field: WebPConfig::target_PSNR"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).segments) as usize - ptr as usize },
        24usize,
        "Offset of field: WebPConfig::segments"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sns_strength) as usize - ptr as usize },
        28usize,
        "Offset of field: WebPConfig::sns_strength"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filter_strength) as usize - ptr as usize },
        32usize,
        "Offset of field: WebPConfig::filter_strength"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filter_sharpness) as usize - ptr as usize },
        36usize,
        "Offset of field: WebPConfig::filter_sharpness"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filter_type) as usize - ptr as usize },
        40usize,
        "Offset of field: WebPConfig::filter_type"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).autofilter) as usize - ptr as usize },
        44usize,
        "Offset of field: WebPConfig::autofilter"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpha_compression) as usize - ptr as usize },
        48usize,
        "Offset of field: WebPConfig::alpha_compression"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpha_filtering) as usize - ptr as usize },
        52usize,
        "Offset of field: WebPConfig::alpha_filtering"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpha_quality) as usize - ptr as usize },
        56usize,
        "Offset of field: WebPConfig::alpha_quality"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pass) as usize - ptr as usize },
        60usize,
        "Offset of field: WebPConfig::pass"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).show_compressed) as usize - ptr as usize },
        64usize,
        "Offset of field: WebPConfig::show_compressed"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).preprocessing) as usize - ptr as usize },
        68usize,
        "Offset of field: WebPConfig::preprocessing"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).partitions) as usize - ptr as usize },
        72usize,
        "Offset of field: WebPConfig::partitions"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).partition_limit) as usize - ptr as usize },
        76usize,
        "Offset of field: WebPConfig::partition_limit"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).emulate_jpeg_size) as usize - ptr as usize },
        80usize,
        "Offset of field: WebPConfig::emulate_jpeg_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_level) as usize - ptr as usize },
        84usize,
        "Offset of field: WebPConfig::thread_level"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).low_memory) as usize - ptr as usize },
        88usize,
        "Offset of field: WebPConfig::low_memory"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).near_lossless) as usize - ptr as usize },
        92usize,
        "Offset of field: WebPConfig::near_lossless"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exact) as usize - ptr as usize },
        96usize,
        "Offset of field: WebPConfig::exact"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).use_delta_palette) as usize - ptr as usize },
        100usize,
        "Offset of field: WebPConfig::use_delta_palette"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).use_sharp_yuv) as usize - ptr as usize },
        104usize,
        "Offset of field: WebPConfig::use_sharp_yuv"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qmin) as usize - ptr as usize },
        108usize,
        "Offset of field: WebPConfig::qmin"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qmax) as usize - ptr as usize },
        112usize,
        "Offset of field: WebPConfig::qmax"
    );
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WebPPreset {
    WEBP_PRESET_DEFAULT = 0,
    WEBP_PRESET_PICTURE = 1,
    WEBP_PRESET_PHOTO = 2,
    WEBP_PRESET_DRAWING = 3,
    WEBP_PRESET_ICON = 4,
    WEBP_PRESET_TEXT = 5,
}
extern "C" {
    pub fn WebPConfigInitInternal(
        arg1: *mut WebPConfig,
        arg2: WebPPreset,
        arg3: f32,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPConfigLosslessPreset(
        config: *mut WebPConfig,
        level: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPValidateConfig(config: *const WebPConfig) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPAuxStats {
    pub coded_size: ::core::ffi::c_int,
    pub PSNR: [f32; 5usize],
    pub block_count: [::core::ffi::c_int; 3usize],
    pub header_bytes: [::core::ffi::c_int; 2usize],
    pub residual_bytes: [[::core::ffi::c_int; 4usize]; 3usize],
    pub segment_size: [::core::ffi::c_int; 4usize],
    pub segment_quant: [::core::ffi::c_int; 4usize],
    pub segment_level: [::core::ffi::c_int; 4usize],
    pub alpha_data_size: ::core::ffi::c_int,
    pub layer_data_size: ::core::ffi::c_int,
    pub lossless_features: u32,
    pub histogram_bits: ::core::ffi::c_int,
    pub transform_bits: ::core::ffi::c_int,
    pub cache_bits: ::core::ffi::c_int,
    pub palette_size: ::core::ffi::c_int,
    pub lossless_size: ::core::ffi::c_int,
    pub lossless_hdr_size: ::core::ffi::c_int,
    pub lossless_data_size: ::core::ffi::c_int,
    pub pad: [u32; 2usize],
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPAuxStats() {
    const UNINIT: ::core::mem::MaybeUninit<WebPAuxStats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPAuxStats>(),
        188usize,
        "Size of WebPAuxStats"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPAuxStats>(),
        4usize,
        "Alignment of WebPAuxStats"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coded_size) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPAuxStats::coded_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PSNR) as usize - ptr as usize },
        4usize,
        "Offset of field: WebPAuxStats::PSNR"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_count) as usize - ptr as usize },
        24usize,
        "Offset of field: WebPAuxStats::block_count"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header_bytes) as usize - ptr as usize },
        36usize,
        "Offset of field: WebPAuxStats::header_bytes"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).residual_bytes) as usize - ptr as usize },
        44usize,
        "Offset of field: WebPAuxStats::residual_bytes"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).segment_size) as usize - ptr as usize },
        92usize,
        "Offset of field: WebPAuxStats::segment_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).segment_quant) as usize - ptr as usize },
        108usize,
        "Offset of field: WebPAuxStats::segment_quant"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).segment_level) as usize - ptr as usize },
        124usize,
        "Offset of field: WebPAuxStats::segment_level"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpha_data_size) as usize - ptr as usize },
        140usize,
        "Offset of field: WebPAuxStats::alpha_data_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).layer_data_size) as usize - ptr as usize },
        144usize,
        "Offset of field: WebPAuxStats::layer_data_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lossless_features) as usize - ptr as usize },
        148usize,
        "Offset of field: WebPAuxStats::lossless_features"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).histogram_bits) as usize - ptr as usize },
        152usize,
        "Offset of field: WebPAuxStats::histogram_bits"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transform_bits) as usize - ptr as usize },
        156usize,
        "Offset of field: WebPAuxStats::transform_bits"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cache_bits) as usize - ptr as usize },
        160usize,
        "Offset of field: WebPAuxStats::cache_bits"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).palette_size) as usize - ptr as usize },
        164usize,
        "Offset of field: WebPAuxStats::palette_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lossless_size) as usize - ptr as usize },
        168usize,
        "Offset of field: WebPAuxStats::lossless_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lossless_hdr_size) as usize - ptr as usize },
        172usize,
        "Offset of field: WebPAuxStats::lossless_hdr_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lossless_data_size) as usize - ptr as usize },
        176usize,
        "Offset of field: WebPAuxStats::lossless_data_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        180usize,
        "Offset of field: WebPAuxStats::pad"
    );
}
pub type WebPWriterFunction = ::core::option::Option<
    unsafe extern "C" fn(
        data: *const u8,
        data_size: usize,
        picture: *const WebPPicture,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPMemoryWriter {
    pub mem: *mut u8,
    pub size: usize,
    pub max_size: usize,
    pub pad: [u32; 1usize],
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPMemoryWriter() {
    const UNINIT: ::core::mem::MaybeUninit<WebPMemoryWriter> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPMemoryWriter>(),
        32usize,
        "Size of WebPMemoryWriter"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPMemoryWriter>(),
        8usize,
        "Alignment of WebPMemoryWriter"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPMemoryWriter::mem"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        "Offset of field: WebPMemoryWriter::size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_size) as usize - ptr as usize },
        16usize,
        "Offset of field: WebPMemoryWriter::max_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        24usize,
        "Offset of field: WebPMemoryWriter::pad"
    );
}
extern "C" {
    pub fn WebPMemoryWriterInit(writer: *mut WebPMemoryWriter);
}
extern "C" {
    pub fn WebPMemoryWriterClear(writer: *mut WebPMemoryWriter);
}
extern "C" {
    pub fn WebPMemoryWrite(
        data: *const u8,
        data_size: usize,
        picture: *const WebPPicture,
    ) -> ::core::ffi::c_int;
}
pub type WebPProgressHook = ::core::option::Option<
    unsafe extern "C" fn(
        percent: ::core::ffi::c_int,
        picture: *const WebPPicture,
    ) -> ::core::ffi::c_int,
>;
impl WebPEncCSP {
    pub const WEBP_CSP_ALPHA_BIT: WebPEncCSP = WebPEncCSP::WEBP_YUV420A;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WebPEncCSP {
    WEBP_YUV420 = 0,
    WEBP_YUV420A = 4,
    WEBP_CSP_UV_MASK = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WebPEncodingError {
    VP8_ENC_OK = 0,
    VP8_ENC_ERROR_OUT_OF_MEMORY = 1,
    VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY = 2,
    VP8_ENC_ERROR_NULL_PARAMETER = 3,
    VP8_ENC_ERROR_INVALID_CONFIGURATION = 4,
    VP8_ENC_ERROR_BAD_DIMENSION = 5,
    VP8_ENC_ERROR_PARTITION0_OVERFLOW = 6,
    VP8_ENC_ERROR_PARTITION_OVERFLOW = 7,
    VP8_ENC_ERROR_BAD_WRITE = 8,
    VP8_ENC_ERROR_FILE_TOO_BIG = 9,
    VP8_ENC_ERROR_USER_ABORT = 10,
    VP8_ENC_ERROR_LAST = 11,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPPicture {
    pub use_argb: ::core::ffi::c_int,
    pub colorspace: WebPEncCSP,
    pub width: ::core::ffi::c_int,
    pub height: ::core::ffi::c_int,
    pub y: *mut u8,
    pub u: *mut u8,
    pub v: *mut u8,
    pub y_stride: ::core::ffi::c_int,
    pub uv_stride: ::core::ffi::c_int,
    pub a: *mut u8,
    pub a_stride: ::core::ffi::c_int,
    pub pad1: [u32; 2usize],
    pub argb: *mut u32,
    pub argb_stride: ::core::ffi::c_int,
    pub pad2: [u32; 3usize],
    pub writer: WebPWriterFunction,
    pub custom_ptr: *mut ::core::ffi::c_void,
    pub extra_info_type: ::core::ffi::c_int,
    pub extra_info: *mut u8,
    pub stats: *mut WebPAuxStats,
    pub error_code: WebPEncodingError,
    pub progress_hook: WebPProgressHook,
    pub user_data: *mut ::core::ffi::c_void,
    pub pad3: [u32; 3usize],
    pub pad4: *mut u8,
    pub pad5: *mut u8,
    pub pad6: [u32; 8usize],
    pub memory_: *mut ::core::ffi::c_void,
    pub memory_argb_: *mut ::core::ffi::c_void,
    pub pad7: [*mut ::core::ffi::c_void; 2usize],
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPPicture() {
    const UNINIT: ::core::mem::MaybeUninit<WebPPicture> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPPicture>(),
        256usize,
        "Size of WebPPicture"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPPicture>(),
        8usize,
        "Alignment of WebPPicture"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).use_argb) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPPicture::use_argb"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        4usize,
        "Offset of field: WebPPicture::colorspace"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        "Offset of field: WebPPicture::width"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        "Offset of field: WebPPicture::height"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        "Offset of field: WebPPicture::y"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        24usize,
        "Offset of field: WebPPicture::u"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        32usize,
        "Offset of field: WebPPicture::v"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y_stride) as usize - ptr as usize },
        40usize,
        "Offset of field: WebPPicture::y_stride"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uv_stride) as usize - ptr as usize },
        44usize,
        "Offset of field: WebPPicture::uv_stride"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        48usize,
        "Offset of field: WebPPicture::a"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a_stride) as usize - ptr as usize },
        56usize,
        "Offset of field: WebPPicture::a_stride"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize },
        60usize,
        "Offset of field: WebPPicture::pad1"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).argb) as usize - ptr as usize },
        72usize,
        "Offset of field: WebPPicture::argb"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).argb_stride) as usize - ptr as usize },
        80usize,
        "Offset of field: WebPPicture::argb_stride"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad2) as usize - ptr as usize },
        84usize,
        "Offset of field: WebPPicture::pad2"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).writer) as usize - ptr as usize },
        96usize,
        "Offset of field: WebPPicture::writer"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).custom_ptr) as usize - ptr as usize },
        104usize,
        "Offset of field: WebPPicture::custom_ptr"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extra_info_type) as usize - ptr as usize },
        112usize,
        "Offset of field: WebPPicture::extra_info_type"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extra_info) as usize - ptr as usize },
        120usize,
        "Offset of field: WebPPicture::extra_info"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stats) as usize - ptr as usize },
        128usize,
        "Offset of field: WebPPicture::stats"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        136usize,
        "Offset of field: WebPPicture::error_code"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).progress_hook) as usize - ptr as usize },
        144usize,
        "Offset of field: WebPPicture::progress_hook"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        152usize,
        "Offset of field: WebPPicture::user_data"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad3) as usize - ptr as usize },
        160usize,
        "Offset of field: WebPPicture::pad3"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad4) as usize - ptr as usize },
        176usize,
        "Offset of field: WebPPicture::pad4"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad5) as usize - ptr as usize },
        184usize,
        "Offset of field: WebPPicture::pad5"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad6) as usize - ptr as usize },
        192usize,
        "Offset of field: WebPPicture::pad6"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memory_) as usize - ptr as usize },
        224usize,
        "Offset of field: WebPPicture::memory_"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memory_argb_) as usize - ptr as usize },
        232usize,
        "Offset of field: WebPPicture::memory_argb_"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad7) as usize - ptr as usize },
        240usize,
        "Offset of field: WebPPicture::pad7"
    );
}
extern "C" {
    pub fn WebPPictureInitInternal(
        arg1: *mut WebPPicture,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureAlloc(picture: *mut WebPPicture) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureFree(picture: *mut WebPPicture);
}
extern "C" {
    pub fn WebPPictureCopy(src: *const WebPPicture, dst: *mut WebPPicture) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPlaneDistortion(
        src: *const u8,
        src_stride: usize,
        ref_: *const u8,
        ref_stride: usize,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        x_step: usize,
        type_: ::core::ffi::c_int,
        distortion: *mut f32,
        result: *mut f32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureDistortion(
        src: *const WebPPicture,
        ref_: *const WebPPicture,
        metric_type: ::core::ffi::c_int,
        result: *mut f32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureCrop(
        picture: *mut WebPPicture,
        left: ::core::ffi::c_int,
        top: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureView(
        src: *const WebPPicture,
        left: ::core::ffi::c_int,
        top: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        dst: *mut WebPPicture,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureIsView(picture: *const WebPPicture) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureRescale(
        picture: *mut WebPPicture,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureImportRGB(
        picture: *mut WebPPicture,
        rgb: *const u8,
        rgb_stride: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureImportRGBA(
        picture: *mut WebPPicture,
        rgba: *const u8,
        rgba_stride: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureImportRGBX(
        picture: *mut WebPPicture,
        rgbx: *const u8,
        rgbx_stride: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureImportBGR(
        picture: *mut WebPPicture,
        bgr: *const u8,
        bgr_stride: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureImportBGRA(
        picture: *mut WebPPicture,
        bgra: *const u8,
        bgra_stride: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureImportBGRX(
        picture: *mut WebPPicture,
        bgrx: *const u8,
        bgrx_stride: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureARGBToYUVA(picture: *mut WebPPicture, arg1: WebPEncCSP)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureARGBToYUVADithered(
        picture: *mut WebPPicture,
        colorspace: WebPEncCSP,
        dithering: f32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureSharpARGBToYUVA(picture: *mut WebPPicture) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureSmartARGBToYUVA(picture: *mut WebPPicture) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPPictureYUVAToARGB(picture: *mut WebPPicture) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPCleanupTransparentArea(picture: *mut WebPPicture);
}
extern "C" {
    pub fn WebPPictureHasTransparency(picture: *const WebPPicture) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPBlendAlpha(picture: *mut WebPPicture, background_rgb: u32);
}
extern "C" {
    pub fn WebPEncode(config: *const WebPConfig, picture: *mut WebPPicture) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPIDecoder {
    _unused: [u8; 0],
}
extern "C" {
    pub fn WebPGetDecoderVersion() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPGetInfo(
        data: *const u8,
        data_size: usize,
        width: *mut ::core::ffi::c_int,
        height: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPDecodeRGBA(
        data: *const u8,
        data_size: usize,
        width: *mut ::core::ffi::c_int,
        height: *mut ::core::ffi::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeARGB(
        data: *const u8,
        data_size: usize,
        width: *mut ::core::ffi::c_int,
        height: *mut ::core::ffi::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeBGRA(
        data: *const u8,
        data_size: usize,
        width: *mut ::core::ffi::c_int,
        height: *mut ::core::ffi::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeRGB(
        data: *const u8,
        data_size: usize,
        width: *mut ::core::ffi::c_int,
        height: *mut ::core::ffi::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeBGR(
        data: *const u8,
        data_size: usize,
        width: *mut ::core::ffi::c_int,
        height: *mut ::core::ffi::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeYUV(
        data: *const u8,
        data_size: usize,
        width: *mut ::core::ffi::c_int,
        height: *mut ::core::ffi::c_int,
        u: *mut *mut u8,
        v: *mut *mut u8,
        stride: *mut ::core::ffi::c_int,
        uv_stride: *mut ::core::ffi::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeRGBAInto(
        data: *const u8,
        data_size: usize,
        output_buffer: *mut u8,
        output_buffer_size: usize,
        output_stride: ::core::ffi::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeARGBInto(
        data: *const u8,
        data_size: usize,
        output_buffer: *mut u8,
        output_buffer_size: usize,
        output_stride: ::core::ffi::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeBGRAInto(
        data: *const u8,
        data_size: usize,
        output_buffer: *mut u8,
        output_buffer_size: usize,
        output_stride: ::core::ffi::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeRGBInto(
        data: *const u8,
        data_size: usize,
        output_buffer: *mut u8,
        output_buffer_size: usize,
        output_stride: ::core::ffi::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeBGRInto(
        data: *const u8,
        data_size: usize,
        output_buffer: *mut u8,
        output_buffer_size: usize,
        output_stride: ::core::ffi::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeYUVInto(
        data: *const u8,
        data_size: usize,
        luma: *mut u8,
        luma_size: usize,
        luma_stride: ::core::ffi::c_int,
        u: *mut u8,
        u_size: usize,
        u_stride: ::core::ffi::c_int,
        v: *mut u8,
        v_size: usize,
        v_stride: ::core::ffi::c_int,
    ) -> *mut u8;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WEBP_CSP_MODE {
    MODE_RGB = 0,
    MODE_RGBA = 1,
    MODE_BGR = 2,
    MODE_BGRA = 3,
    MODE_ARGB = 4,
    MODE_RGBA_4444 = 5,
    MODE_RGB_565 = 6,
    MODE_rgbA = 7,
    MODE_bgrA = 8,
    MODE_Argb = 9,
    MODE_rgbA_4444 = 10,
    MODE_YUV = 11,
    MODE_YUVA = 12,
    MODE_LAST = 13,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPRGBABuffer {
    pub rgba: *mut u8,
    pub stride: ::core::ffi::c_int,
    pub size: usize,
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPRGBABuffer() {
    const UNINIT: ::core::mem::MaybeUninit<WebPRGBABuffer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPRGBABuffer>(),
        24usize,
        "Size of WebPRGBABuffer"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPRGBABuffer>(),
        8usize,
        "Alignment of WebPRGBABuffer"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rgba) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPRGBABuffer::rgba"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        "Offset of field: WebPRGBABuffer::stride"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        "Offset of field: WebPRGBABuffer::size"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPYUVABuffer {
    pub y: *mut u8,
    pub u: *mut u8,
    pub v: *mut u8,
    pub a: *mut u8,
    pub y_stride: ::core::ffi::c_int,
    pub u_stride: ::core::ffi::c_int,
    pub v_stride: ::core::ffi::c_int,
    pub a_stride: ::core::ffi::c_int,
    pub y_size: usize,
    pub u_size: usize,
    pub v_size: usize,
    pub a_size: usize,
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPYUVABuffer() {
    const UNINIT: ::core::mem::MaybeUninit<WebPYUVABuffer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPYUVABuffer>(),
        80usize,
        "Size of WebPYUVABuffer"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPYUVABuffer>(),
        8usize,
        "Alignment of WebPYUVABuffer"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPYUVABuffer::y"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        "Offset of field: WebPYUVABuffer::u"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        16usize,
        "Offset of field: WebPYUVABuffer::v"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        24usize,
        "Offset of field: WebPYUVABuffer::a"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y_stride) as usize - ptr as usize },
        32usize,
        "Offset of field: WebPYUVABuffer::y_stride"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u_stride) as usize - ptr as usize },
        36usize,
        "Offset of field: WebPYUVABuffer::u_stride"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_stride) as usize - ptr as usize },
        40usize,
        "Offset of field: WebPYUVABuffer::v_stride"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a_stride) as usize - ptr as usize },
        44usize,
        "Offset of field: WebPYUVABuffer::a_stride"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y_size) as usize - ptr as usize },
        48usize,
        "Offset of field: WebPYUVABuffer::y_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u_size) as usize - ptr as usize },
        56usize,
        "Offset of field: WebPYUVABuffer::u_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_size) as usize - ptr as usize },
        64usize,
        "Offset of field: WebPYUVABuffer::v_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a_size) as usize - ptr as usize },
        72usize,
        "Offset of field: WebPYUVABuffer::a_size"
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WebPDecBuffer {
    pub colorspace: WEBP_CSP_MODE,
    pub width: ::core::ffi::c_int,
    pub height: ::core::ffi::c_int,
    pub is_external_memory: ::core::ffi::c_int,
    pub u: WebPDecBuffer__bindgen_ty_1,
    pub pad: [u32; 4usize],
    pub private_memory: *mut u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WebPDecBuffer__bindgen_ty_1 {
    pub RGBA: WebPRGBABuffer,
    pub YUVA: WebPYUVABuffer,
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPDecBuffer__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<WebPDecBuffer__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPDecBuffer__bindgen_ty_1>(),
        80usize,
        "Size of WebPDecBuffer__bindgen_ty_1"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPDecBuffer__bindgen_ty_1>(),
        8usize,
        "Alignment of WebPDecBuffer__bindgen_ty_1"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RGBA) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPDecBuffer__bindgen_ty_1::RGBA"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).YUVA) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPDecBuffer__bindgen_ty_1::YUVA"
    );
}
impl ::core::fmt::Debug for WebPDecBuffer__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "WebPDecBuffer__bindgen_ty_1 {{ union }}")
    }
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPDecBuffer() {
    const UNINIT: ::core::mem::MaybeUninit<WebPDecBuffer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPDecBuffer>(),
        120usize,
        "Size of WebPDecBuffer"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPDecBuffer>(),
        8usize,
        "Alignment of WebPDecBuffer"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPDecBuffer::colorspace"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        "Offset of field: WebPDecBuffer::width"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        "Offset of field: WebPDecBuffer::height"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_external_memory) as usize - ptr as usize },
        12usize,
        "Offset of field: WebPDecBuffer::is_external_memory"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        16usize,
        "Offset of field: WebPDecBuffer::u"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        96usize,
        "Offset of field: WebPDecBuffer::pad"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private_memory) as usize - ptr as usize },
        112usize,
        "Offset of field: WebPDecBuffer::private_memory"
    );
}
impl ::core::fmt::Debug for WebPDecBuffer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "WebPDecBuffer {{ colorspace: {:?}, width: {:?}, height: {:?}, is_external_memory: {:?}, u: {:?}, pad: {:?}, private_memory: {:?} }}" , self . colorspace , self . width , self . height , self . is_external_memory , self . u , self . pad , self . private_memory)
    }
}
extern "C" {
    pub fn WebPInitDecBufferInternal(
        arg1: *mut WebPDecBuffer,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPFreeDecBuffer(buffer: *mut WebPDecBuffer);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VP8StatusCode {
    VP8_STATUS_OK = 0,
    VP8_STATUS_OUT_OF_MEMORY = 1,
    VP8_STATUS_INVALID_PARAM = 2,
    VP8_STATUS_BITSTREAM_ERROR = 3,
    VP8_STATUS_UNSUPPORTED_FEATURE = 4,
    VP8_STATUS_SUSPENDED = 5,
    VP8_STATUS_USER_ABORT = 6,
    VP8_STATUS_NOT_ENOUGH_DATA = 7,
}
extern "C" {
    pub fn WebPINewDecoder(output_buffer: *mut WebPDecBuffer) -> *mut WebPIDecoder;
}
extern "C" {
    pub fn WebPINewRGB(
        csp: WEBP_CSP_MODE,
        output_buffer: *mut u8,
        output_buffer_size: usize,
        output_stride: ::core::ffi::c_int,
    ) -> *mut WebPIDecoder;
}
extern "C" {
    pub fn WebPINewYUVA(
        luma: *mut u8,
        luma_size: usize,
        luma_stride: ::core::ffi::c_int,
        u: *mut u8,
        u_size: usize,
        u_stride: ::core::ffi::c_int,
        v: *mut u8,
        v_size: usize,
        v_stride: ::core::ffi::c_int,
        a: *mut u8,
        a_size: usize,
        a_stride: ::core::ffi::c_int,
    ) -> *mut WebPIDecoder;
}
extern "C" {
    pub fn WebPINewYUV(
        luma: *mut u8,
        luma_size: usize,
        luma_stride: ::core::ffi::c_int,
        u: *mut u8,
        u_size: usize,
        u_stride: ::core::ffi::c_int,
        v: *mut u8,
        v_size: usize,
        v_stride: ::core::ffi::c_int,
    ) -> *mut WebPIDecoder;
}
extern "C" {
    pub fn WebPIDelete(idec: *mut WebPIDecoder);
}
extern "C" {
    pub fn WebPIAppend(idec: *mut WebPIDecoder, data: *const u8, data_size: usize)
        -> VP8StatusCode;
}
extern "C" {
    pub fn WebPIUpdate(idec: *mut WebPIDecoder, data: *const u8, data_size: usize)
        -> VP8StatusCode;
}
extern "C" {
    pub fn WebPIDecGetRGB(
        idec: *const WebPIDecoder,
        last_y: *mut ::core::ffi::c_int,
        width: *mut ::core::ffi::c_int,
        height: *mut ::core::ffi::c_int,
        stride: *mut ::core::ffi::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn WebPIDecGetYUVA(
        idec: *const WebPIDecoder,
        last_y: *mut ::core::ffi::c_int,
        u: *mut *mut u8,
        v: *mut *mut u8,
        a: *mut *mut u8,
        width: *mut ::core::ffi::c_int,
        height: *mut ::core::ffi::c_int,
        stride: *mut ::core::ffi::c_int,
        uv_stride: *mut ::core::ffi::c_int,
        a_stride: *mut ::core::ffi::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn WebPIDecodedArea(
        idec: *const WebPIDecoder,
        left: *mut ::core::ffi::c_int,
        top: *mut ::core::ffi::c_int,
        width: *mut ::core::ffi::c_int,
        height: *mut ::core::ffi::c_int,
    ) -> *const WebPDecBuffer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPBitstreamFeatures {
    pub width: ::core::ffi::c_int,
    pub height: ::core::ffi::c_int,
    pub has_alpha: ::core::ffi::c_int,
    pub has_animation: ::core::ffi::c_int,
    pub format: ::core::ffi::c_int,
    pub pad: [u32; 5usize],
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPBitstreamFeatures() {
    const UNINIT: ::core::mem::MaybeUninit<WebPBitstreamFeatures> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPBitstreamFeatures>(),
        40usize,
        "Size of WebPBitstreamFeatures"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPBitstreamFeatures>(),
        4usize,
        "Alignment of WebPBitstreamFeatures"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPBitstreamFeatures::width"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        "Offset of field: WebPBitstreamFeatures::height"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_alpha) as usize - ptr as usize },
        8usize,
        "Offset of field: WebPBitstreamFeatures::has_alpha"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_animation) as usize - ptr as usize },
        12usize,
        "Offset of field: WebPBitstreamFeatures::has_animation"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        16usize,
        "Offset of field: WebPBitstreamFeatures::format"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        20usize,
        "Offset of field: WebPBitstreamFeatures::pad"
    );
}
extern "C" {
    pub fn WebPGetFeaturesInternal(
        arg1: *const u8,
        arg2: usize,
        arg3: *mut WebPBitstreamFeatures,
        arg4: ::core::ffi::c_int,
    ) -> VP8StatusCode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPDecoderOptions {
    pub bypass_filtering: ::core::ffi::c_int,
    pub no_fancy_upsampling: ::core::ffi::c_int,
    pub use_cropping: ::core::ffi::c_int,
    pub crop_left: ::core::ffi::c_int,
    pub crop_top: ::core::ffi::c_int,
    pub crop_width: ::core::ffi::c_int,
    pub crop_height: ::core::ffi::c_int,
    pub use_scaling: ::core::ffi::c_int,
    pub scaled_width: ::core::ffi::c_int,
    pub scaled_height: ::core::ffi::c_int,
    pub use_threads: ::core::ffi::c_int,
    pub dithering_strength: ::core::ffi::c_int,
    pub flip: ::core::ffi::c_int,
    pub alpha_dithering_strength: ::core::ffi::c_int,
    pub pad: [u32; 5usize],
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPDecoderOptions() {
    const UNINIT: ::core::mem::MaybeUninit<WebPDecoderOptions> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPDecoderOptions>(),
        76usize,
        "Size of WebPDecoderOptions"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPDecoderOptions>(),
        4usize,
        "Alignment of WebPDecoderOptions"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bypass_filtering) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPDecoderOptions::bypass_filtering"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).no_fancy_upsampling) as usize - ptr as usize },
        4usize,
        "Offset of field: WebPDecoderOptions::no_fancy_upsampling"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).use_cropping) as usize - ptr as usize },
        8usize,
        "Offset of field: WebPDecoderOptions::use_cropping"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crop_left) as usize - ptr as usize },
        12usize,
        "Offset of field: WebPDecoderOptions::crop_left"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crop_top) as usize - ptr as usize },
        16usize,
        "Offset of field: WebPDecoderOptions::crop_top"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crop_width) as usize - ptr as usize },
        20usize,
        "Offset of field: WebPDecoderOptions::crop_width"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crop_height) as usize - ptr as usize },
        24usize,
        "Offset of field: WebPDecoderOptions::crop_height"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).use_scaling) as usize - ptr as usize },
        28usize,
        "Offset of field: WebPDecoderOptions::use_scaling"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scaled_width) as usize - ptr as usize },
        32usize,
        "Offset of field: WebPDecoderOptions::scaled_width"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scaled_height) as usize - ptr as usize },
        36usize,
        "Offset of field: WebPDecoderOptions::scaled_height"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).use_threads) as usize - ptr as usize },
        40usize,
        "Offset of field: WebPDecoderOptions::use_threads"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dithering_strength) as usize - ptr as usize },
        44usize,
        "Offset of field: WebPDecoderOptions::dithering_strength"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flip) as usize - ptr as usize },
        48usize,
        "Offset of field: WebPDecoderOptions::flip"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alpha_dithering_strength) as usize - ptr as usize },
        52usize,
        "Offset of field: WebPDecoderOptions::alpha_dithering_strength"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        56usize,
        "Offset of field: WebPDecoderOptions::pad"
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WebPDecoderConfig {
    pub input: WebPBitstreamFeatures,
    pub output: WebPDecBuffer,
    pub options: WebPDecoderOptions,
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPDecoderConfig() {
    const UNINIT: ::core::mem::MaybeUninit<WebPDecoderConfig> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPDecoderConfig>(),
        240usize,
        "Size of WebPDecoderConfig"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPDecoderConfig>(),
        8usize,
        "Alignment of WebPDecoderConfig"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPDecoderConfig::input"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        40usize,
        "Offset of field: WebPDecoderConfig::output"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        160usize,
        "Offset of field: WebPDecoderConfig::options"
    );
}
impl ::core::fmt::Debug for WebPDecoderConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "WebPDecoderConfig {{ input: {:?}, output: {:?}, options: {:?} }}",
            self.input, self.output, self.options
        )
    }
}
extern "C" {
    pub fn WebPInitDecoderConfigInternal(
        arg1: *mut WebPDecoderConfig,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPIDecode(
        data: *const u8,
        data_size: usize,
        config: *mut WebPDecoderConfig,
    ) -> *mut WebPIDecoder;
}
extern "C" {
    pub fn WebPDecode(
        data: *const u8,
        data_size: usize,
        config: *mut WebPDecoderConfig,
    ) -> VP8StatusCode;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WebPFeatureFlags {
    ANIMATION_FLAG = 2,
    XMP_FLAG = 4,
    EXIF_FLAG = 8,
    ALPHA_FLAG = 16,
    ICCP_FLAG = 32,
    ALL_VALID_FLAGS = 62,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WebPMuxAnimDispose {
    WEBP_MUX_DISPOSE_NONE = 0,
    WEBP_MUX_DISPOSE_BACKGROUND = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WebPMuxAnimBlend {
    WEBP_MUX_BLEND = 0,
    WEBP_MUX_NO_BLEND = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPData {
    pub bytes: *const u8,
    pub size: usize,
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPData() {
    const UNINIT: ::core::mem::MaybeUninit<WebPData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPData>(),
        16usize,
        "Size of WebPData"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPData>(),
        8usize,
        "Alignment of WebPData"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPData::bytes"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        "Offset of field: WebPData::size"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPMux {
    _unused: [u8; 0],
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WebPMuxError {
    WEBP_MUX_OK = 1,
    WEBP_MUX_NOT_FOUND = 0,
    WEBP_MUX_INVALID_ARGUMENT = -1,
    WEBP_MUX_BAD_DATA = -2,
    WEBP_MUX_MEMORY_ERROR = -3,
    WEBP_MUX_NOT_ENOUGH_DATA = -4,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WebPChunkId {
    WEBP_CHUNK_VP8X = 0,
    WEBP_CHUNK_ICCP = 1,
    WEBP_CHUNK_ANIM = 2,
    WEBP_CHUNK_ANMF = 3,
    WEBP_CHUNK_DEPRECATED = 4,
    WEBP_CHUNK_ALPHA = 5,
    WEBP_CHUNK_IMAGE = 6,
    WEBP_CHUNK_EXIF = 7,
    WEBP_CHUNK_XMP = 8,
    WEBP_CHUNK_UNKNOWN = 9,
    WEBP_CHUNK_NIL = 10,
}
extern "C" {
    pub fn WebPGetMuxVersion() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPNewInternal(arg1: ::core::ffi::c_int) -> *mut WebPMux;
}
extern "C" {
    pub fn WebPMuxDelete(mux: *mut WebPMux);
}
extern "C" {
    pub fn WebPMuxCreateInternal(
        arg1: *const WebPData,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
    ) -> *mut WebPMux;
}
extern "C" {
    pub fn WebPMuxSetChunk(
        mux: *mut WebPMux,
        fourcc: *const ::core::ffi::c_char,
        chunk_data: *const WebPData,
        copy_data: ::core::ffi::c_int,
    ) -> WebPMuxError;
}
extern "C" {
    pub fn WebPMuxGetChunk(
        mux: *const WebPMux,
        fourcc: *const ::core::ffi::c_char,
        chunk_data: *mut WebPData,
    ) -> WebPMuxError;
}
extern "C" {
    pub fn WebPMuxDeleteChunk(
        mux: *mut WebPMux,
        fourcc: *const ::core::ffi::c_char,
    ) -> WebPMuxError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPMuxFrameInfo {
    pub bitstream: WebPData,
    pub x_offset: ::core::ffi::c_int,
    pub y_offset: ::core::ffi::c_int,
    pub duration: ::core::ffi::c_int,
    pub id: WebPChunkId,
    pub dispose_method: WebPMuxAnimDispose,
    pub blend_method: WebPMuxAnimBlend,
    pub pad: [u32; 1usize],
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPMuxFrameInfo() {
    const UNINIT: ::core::mem::MaybeUninit<WebPMuxFrameInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPMuxFrameInfo>(),
        48usize,
        "Size of WebPMuxFrameInfo"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPMuxFrameInfo>(),
        8usize,
        "Alignment of WebPMuxFrameInfo"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitstream) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPMuxFrameInfo::bitstream"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x_offset) as usize - ptr as usize },
        16usize,
        "Offset of field: WebPMuxFrameInfo::x_offset"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y_offset) as usize - ptr as usize },
        20usize,
        "Offset of field: WebPMuxFrameInfo::y_offset"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        24usize,
        "Offset of field: WebPMuxFrameInfo::duration"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        28usize,
        "Offset of field: WebPMuxFrameInfo::id"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dispose_method) as usize - ptr as usize },
        32usize,
        "Offset of field: WebPMuxFrameInfo::dispose_method"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blend_method) as usize - ptr as usize },
        36usize,
        "Offset of field: WebPMuxFrameInfo::blend_method"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        40usize,
        "Offset of field: WebPMuxFrameInfo::pad"
    );
}
extern "C" {
    pub fn WebPMuxSetImage(
        mux: *mut WebPMux,
        bitstream: *const WebPData,
        copy_data: ::core::ffi::c_int,
    ) -> WebPMuxError;
}
extern "C" {
    pub fn WebPMuxPushFrame(
        mux: *mut WebPMux,
        frame: *const WebPMuxFrameInfo,
        copy_data: ::core::ffi::c_int,
    ) -> WebPMuxError;
}
extern "C" {
    pub fn WebPMuxGetFrame(
        mux: *const WebPMux,
        nth: u32,
        frame: *mut WebPMuxFrameInfo,
    ) -> WebPMuxError;
}
extern "C" {
    pub fn WebPMuxDeleteFrame(mux: *mut WebPMux, nth: u32) -> WebPMuxError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPMuxAnimParams {
    pub bgcolor: u32,
    pub loop_count: ::core::ffi::c_int,
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPMuxAnimParams() {
    const UNINIT: ::core::mem::MaybeUninit<WebPMuxAnimParams> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPMuxAnimParams>(),
        8usize,
        "Size of WebPMuxAnimParams"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPMuxAnimParams>(),
        4usize,
        "Alignment of WebPMuxAnimParams"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bgcolor) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPMuxAnimParams::bgcolor"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loop_count) as usize - ptr as usize },
        4usize,
        "Offset of field: WebPMuxAnimParams::loop_count"
    );
}
extern "C" {
    pub fn WebPMuxSetAnimationParams(
        mux: *mut WebPMux,
        params: *const WebPMuxAnimParams,
    ) -> WebPMuxError;
}
extern "C" {
    pub fn WebPMuxGetAnimationParams(
        mux: *const WebPMux,
        params: *mut WebPMuxAnimParams,
    ) -> WebPMuxError;
}
extern "C" {
    pub fn WebPMuxSetCanvasSize(
        mux: *mut WebPMux,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) -> WebPMuxError;
}
extern "C" {
    pub fn WebPMuxGetCanvasSize(
        mux: *const WebPMux,
        width: *mut ::core::ffi::c_int,
        height: *mut ::core::ffi::c_int,
    ) -> WebPMuxError;
}
extern "C" {
    pub fn WebPMuxGetFeatures(mux: *const WebPMux, flags: *mut u32) -> WebPMuxError;
}
extern "C" {
    pub fn WebPMuxNumChunks(
        mux: *const WebPMux,
        id: WebPChunkId,
        num_elements: *mut ::core::ffi::c_int,
    ) -> WebPMuxError;
}
extern "C" {
    pub fn WebPMuxAssemble(mux: *mut WebPMux, assembled_data: *mut WebPData) -> WebPMuxError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPAnimEncoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPAnimEncoderOptions {
    pub anim_params: WebPMuxAnimParams,
    pub minimize_size: ::core::ffi::c_int,
    pub kmin: ::core::ffi::c_int,
    pub kmax: ::core::ffi::c_int,
    pub allow_mixed: ::core::ffi::c_int,
    pub verbose: ::core::ffi::c_int,
    pub padding: [u32; 4usize],
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPAnimEncoderOptions() {
    const UNINIT: ::core::mem::MaybeUninit<WebPAnimEncoderOptions> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPAnimEncoderOptions>(),
        44usize,
        "Size of WebPAnimEncoderOptions"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPAnimEncoderOptions>(),
        4usize,
        "Alignment of WebPAnimEncoderOptions"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).anim_params) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPAnimEncoderOptions::anim_params"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minimize_size) as usize - ptr as usize },
        8usize,
        "Offset of field: WebPAnimEncoderOptions::minimize_size"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kmin) as usize - ptr as usize },
        12usize,
        "Offset of field: WebPAnimEncoderOptions::kmin"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kmax) as usize - ptr as usize },
        16usize,
        "Offset of field: WebPAnimEncoderOptions::kmax"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allow_mixed) as usize - ptr as usize },
        20usize,
        "Offset of field: WebPAnimEncoderOptions::allow_mixed"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).verbose) as usize - ptr as usize },
        24usize,
        "Offset of field: WebPAnimEncoderOptions::verbose"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        28usize,
        "Offset of field: WebPAnimEncoderOptions::padding"
    );
}
extern "C" {
    pub fn WebPAnimEncoderOptionsInitInternal(
        arg1: *mut WebPAnimEncoderOptions,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPAnimEncoderNewInternal(
        arg1: ::core::ffi::c_int,
        arg2: ::core::ffi::c_int,
        arg3: *const WebPAnimEncoderOptions,
        arg4: ::core::ffi::c_int,
    ) -> *mut WebPAnimEncoder;
}
extern "C" {
    pub fn WebPAnimEncoderAdd(
        enc: *mut WebPAnimEncoder,
        frame: *mut WebPPicture,
        timestamp_ms: ::core::ffi::c_int,
        config: *const WebPConfig,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPAnimEncoderAssemble(
        enc: *mut WebPAnimEncoder,
        webp_data: *mut WebPData,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPAnimEncoderGetError(enc: *mut WebPAnimEncoder) -> *const ::core::ffi::c_char;
}
extern "C" {
    pub fn WebPAnimEncoderDelete(enc: *mut WebPAnimEncoder);
}
extern "C" {
    pub fn WebPAnimEncoderSetChunk(
        enc: *mut WebPAnimEncoder,
        fourcc: *const ::core::ffi::c_char,
        chunk_data: *const WebPData,
        copy_data: ::core::ffi::c_int,
    ) -> WebPMuxError;
}
extern "C" {
    pub fn WebPAnimEncoderGetChunk(
        enc: *const WebPAnimEncoder,
        fourcc: *const ::core::ffi::c_char,
        chunk_data: *mut WebPData,
    ) -> WebPMuxError;
}
extern "C" {
    pub fn WebPAnimEncoderDeleteChunk(
        enc: *mut WebPAnimEncoder,
        fourcc: *const ::core::ffi::c_char,
    ) -> WebPMuxError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPDemuxer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn WebPGetDemuxVersion() -> ::core::ffi::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WebPDemuxState {
    WEBP_DEMUX_PARSE_ERROR = -1,
    WEBP_DEMUX_PARSING_HEADER = 0,
    WEBP_DEMUX_PARSED_HEADER = 1,
    WEBP_DEMUX_DONE = 2,
}
extern "C" {
    pub fn WebPDemuxInternal(
        arg1: *const WebPData,
        arg2: ::core::ffi::c_int,
        arg3: *mut WebPDemuxState,
        arg4: ::core::ffi::c_int,
    ) -> *mut WebPDemuxer;
}
extern "C" {
    pub fn WebPDemuxDelete(dmux: *mut WebPDemuxer);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WebPFormatFeature {
    WEBP_FF_FORMAT_FLAGS = 0,
    WEBP_FF_CANVAS_WIDTH = 1,
    WEBP_FF_CANVAS_HEIGHT = 2,
    WEBP_FF_LOOP_COUNT = 3,
    WEBP_FF_BACKGROUND_COLOR = 4,
    WEBP_FF_FRAME_COUNT = 5,
}
extern "C" {
    pub fn WebPDemuxGetI(dmux: *const WebPDemuxer, feature: WebPFormatFeature) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPIterator {
    pub frame_num: ::core::ffi::c_int,
    pub num_frames: ::core::ffi::c_int,
    pub x_offset: ::core::ffi::c_int,
    pub y_offset: ::core::ffi::c_int,
    pub width: ::core::ffi::c_int,
    pub height: ::core::ffi::c_int,
    pub duration: ::core::ffi::c_int,
    pub dispose_method: WebPMuxAnimDispose,
    pub complete: ::core::ffi::c_int,
    pub fragment: WebPData,
    pub has_alpha: ::core::ffi::c_int,
    pub blend_method: WebPMuxAnimBlend,
    pub pad: [u32; 2usize],
    pub private_: *mut ::core::ffi::c_void,
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPIterator() {
    const UNINIT: ::core::mem::MaybeUninit<WebPIterator> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPIterator>(),
        80usize,
        "Size of WebPIterator"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPIterator>(),
        8usize,
        "Alignment of WebPIterator"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_num) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPIterator::frame_num"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_frames) as usize - ptr as usize },
        4usize,
        "Offset of field: WebPIterator::num_frames"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x_offset) as usize - ptr as usize },
        8usize,
        "Offset of field: WebPIterator::x_offset"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y_offset) as usize - ptr as usize },
        12usize,
        "Offset of field: WebPIterator::y_offset"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        16usize,
        "Offset of field: WebPIterator::width"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        20usize,
        "Offset of field: WebPIterator::height"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        24usize,
        "Offset of field: WebPIterator::duration"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dispose_method) as usize - ptr as usize },
        28usize,
        "Offset of field: WebPIterator::dispose_method"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).complete) as usize - ptr as usize },
        32usize,
        "Offset of field: WebPIterator::complete"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fragment) as usize - ptr as usize },
        40usize,
        "Offset of field: WebPIterator::fragment"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_alpha) as usize - ptr as usize },
        56usize,
        "Offset of field: WebPIterator::has_alpha"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blend_method) as usize - ptr as usize },
        60usize,
        "Offset of field: WebPIterator::blend_method"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        64usize,
        "Offset of field: WebPIterator::pad"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private_) as usize - ptr as usize },
        72usize,
        "Offset of field: WebPIterator::private_"
    );
}
extern "C" {
    pub fn WebPDemuxGetFrame(
        dmux: *const WebPDemuxer,
        frame_number: ::core::ffi::c_int,
        iter: *mut WebPIterator,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPDemuxNextFrame(iter: *mut WebPIterator) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPDemuxPrevFrame(iter: *mut WebPIterator) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPDemuxReleaseIterator(iter: *mut WebPIterator);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPChunkIterator {
    pub chunk_num: ::core::ffi::c_int,
    pub num_chunks: ::core::ffi::c_int,
    pub chunk: WebPData,
    pub pad: [u32; 6usize],
    pub private_: *mut ::core::ffi::c_void,
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPChunkIterator() {
    const UNINIT: ::core::mem::MaybeUninit<WebPChunkIterator> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPChunkIterator>(),
        56usize,
        "Size of WebPChunkIterator"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPChunkIterator>(),
        8usize,
        "Alignment of WebPChunkIterator"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chunk_num) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPChunkIterator::chunk_num"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_chunks) as usize - ptr as usize },
        4usize,
        "Offset of field: WebPChunkIterator::num_chunks"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chunk) as usize - ptr as usize },
        8usize,
        "Offset of field: WebPChunkIterator::chunk"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        24usize,
        "Offset of field: WebPChunkIterator::pad"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private_) as usize - ptr as usize },
        48usize,
        "Offset of field: WebPChunkIterator::private_"
    );
}
extern "C" {
    pub fn WebPDemuxGetChunk(
        dmux: *const WebPDemuxer,
        fourcc: *const ::core::ffi::c_char,
        chunk_number: ::core::ffi::c_int,
        iter: *mut WebPChunkIterator,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPDemuxNextChunk(iter: *mut WebPChunkIterator) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPDemuxPrevChunk(iter: *mut WebPChunkIterator) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPDemuxReleaseChunkIterator(iter: *mut WebPChunkIterator);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPAnimDecoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPAnimDecoderOptions {
    pub color_mode: WEBP_CSP_MODE,
    pub use_threads: ::core::ffi::c_int,
    pub padding: [u32; 7usize],
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPAnimDecoderOptions() {
    const UNINIT: ::core::mem::MaybeUninit<WebPAnimDecoderOptions> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPAnimDecoderOptions>(),
        36usize,
        "Size of WebPAnimDecoderOptions"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPAnimDecoderOptions>(),
        4usize,
        "Alignment of WebPAnimDecoderOptions"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).color_mode) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPAnimDecoderOptions::color_mode"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).use_threads) as usize - ptr as usize },
        4usize,
        "Offset of field: WebPAnimDecoderOptions::use_threads"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        8usize,
        "Offset of field: WebPAnimDecoderOptions::padding"
    );
}
extern "C" {
    pub fn WebPAnimDecoderOptionsInitInternal(
        arg1: *mut WebPAnimDecoderOptions,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPAnimDecoderNewInternal(
        arg1: *const WebPData,
        arg2: *const WebPAnimDecoderOptions,
        arg3: ::core::ffi::c_int,
    ) -> *mut WebPAnimDecoder;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPAnimInfo {
    pub canvas_width: u32,
    pub canvas_height: u32,
    pub loop_count: u32,
    pub bgcolor: u32,
    pub frame_count: u32,
    pub pad: [u32; 4usize],
}
#[test]
#[cfg(not(target_pointer_width = "32"))]
fn bindgen_test_layout_WebPAnimInfo() {
    const UNINIT: ::core::mem::MaybeUninit<WebPAnimInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WebPAnimInfo>(),
        36usize,
        "Size of WebPAnimInfo"
    );
    assert_eq!(
        ::core::mem::align_of::<WebPAnimInfo>(),
        4usize,
        "Alignment of WebPAnimInfo"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).canvas_width) as usize - ptr as usize },
        0usize,
        "Offset of field: WebPAnimInfo::canvas_width"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).canvas_height) as usize - ptr as usize },
        4usize,
        "Offset of field: WebPAnimInfo::canvas_height"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loop_count) as usize - ptr as usize },
        8usize,
        "Offset of field: WebPAnimInfo::loop_count"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bgcolor) as usize - ptr as usize },
        12usize,
        "Offset of field: WebPAnimInfo::bgcolor"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_count) as usize - ptr as usize },
        16usize,
        "Offset of field: WebPAnimInfo::frame_count"
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        20usize,
        "Offset of field: WebPAnimInfo::pad"
    );
}
extern "C" {
    pub fn WebPAnimDecoderGetInfo(
        dec: *const WebPAnimDecoder,
        info: *mut WebPAnimInfo,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPAnimDecoderGetNext(
        dec: *mut WebPAnimDecoder,
        buf: *mut *mut u8,
        timestamp: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPAnimDecoderHasMoreFrames(dec: *const WebPAnimDecoder) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn WebPAnimDecoderReset(dec: *mut WebPAnimDecoder);
}
extern "C" {
    pub fn WebPAnimDecoderGetDemuxer(dec: *const WebPAnimDecoder) -> *const WebPDemuxer;
}
extern "C" {
    pub fn WebPAnimDecoderDelete(dec: *mut WebPAnimDecoder);
}
